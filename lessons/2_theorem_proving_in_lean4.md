# Theorem Proving in Lean 导读

[英文原版](https://lean-lang.org/theorem_proving_in_lean4/)

[中文版](https://www.leanprover.cn/tp-lean-zh/)

## 第一章：简介

### 导读

这一章是介绍一些基础的概念，介绍了计算机和定理证明的历史和Lean的诞生。

如果在这一章中遇到了你理解不了的名词，你可以放心的先跳过，在后面的学习中用身体去感受。

### 补充阅读

有一个概念需要单独提出作为补充： 什么是 [**公理系统**](https://zh.wikipedia.org/wiki/%E5%85%AC%E7%90%86%E7%B3%BB%E7%BB%9F)

事实上，*Lean并不会保证你证明的结论是一定正确的*。Lean只能保证，**在你给定的公理系统下，你证明的某个定理是成立的**。

比如，“一个命题要么是真，要么是假” 这个听起来有道理的论断（被叫做[排中律](https://zh.wikipedia.org/wiki/%E6%8E%92%E4%B8%AD%E5%BE%8B)），本身无法被直接证明，所以我们把它当做 “经典逻辑系统” 的一部分。

然而，你也可以不承认排中律，构建其他的公理系统（比如直觉逻辑系统），你也可以得到一部分有趣的结论，并非所有的定理都依赖排中律。

另外，你也可以引入一些并不符合常识的公理，比如 $1>2$ 。引入这种公理可能会和现有的其他公理产生矛盾。后面我们会看到，如果发生了这种事，你可能可以证明出“False”为真，然后随之可以证明出所有的命题都为真。这时候我们叫做这个系统“不自洽”。“不自洽”的系统通常没有太大研究的价值（因为所有命题都可以被证明为真），所以我们通常所研究的公理系统应当是自洽的。

Lean的另一个作用就是，**在你完成一个证明后，Lean可以自动帮你推导出你的证明实际依赖了哪些公理**。在数学研究中，有时候需要研究一个公理的独立性。

* 如果你从一些基础公理能够证明出一个新的命题，那么这个新命题不是独立的。
* 如果你能够证明 不能从基础公理证明出一个新的命题，那这个命题是独立的。
    * 注意“不能证明”本身也是需要证明的，只是“没有做到”并非严格的独立性证明。
    * 证明独立性的一种方法，是 如果存在一个基础命题推导出该新命题的证明，则可以推出一个矛盾，那么就可以证明不存在这样的证明了。

### 补充习题

* 回忆一下你在数学中学习过的证明，或者上网搜索一个关于任意数学命题的证明，想一想，他依赖了哪些公理？
    * 未来在你学习完Lean的形式化证明之后，试着形式化一下这个命题，看看它到底依赖了哪些公理，和你最初的想象一样吗？

## 第二章：依值类型论

### 导读

这一章主要是讲解了Lean 4中的类型系统和相关的语法及概念。

对于计算机出身的，或者至少学习过一门以上静态类型语言（比如C++或Java）的同学来说 这一章的大部分内容应该比较轻松。你可以先阅读，然后再来阅读接下来的补充材料。

### 补充阅读

相信这一章的大部分内容阅读起来不算困难，有几个重要的点（也是和C++或Java等语言的不同之处）需要注意：

* 函数是一等公民
    * 就像JavaScript、Python等语言一样
    * 函数可以作为参数传递，也可以返回，支持高阶函数等等
* 类型也是一等公民
    * 这是极少语言具备的特性，只有C++模板元编程 有类似的特性。
        * 但C++的模板元编程和普通代码语法截然不同
        * 而Lean中处理类型的函数和普通函数语法上是一致的。虽然这种函数（依值类型函数）只能在编译期使用，不会生成任何的可执行代码。
    * 这意味着“模板类型”、“模板函数”、“普通函数”这在C++里截然不同的三个东西，在Lean中其实是一样的表达。
    * 这意味着类型本身也有类型，这就是类型宇宙的概念。
        * 大部分时候并不需要具体的关心类型属于哪个宇宙，可以使用多态来处理不同的类型宇宙
* 有很多类型的推导可以自动完成
    * 实际上这是比想象的重要的多的特性，很多证明过程、对命题的模式匹配等都广泛依赖这个特性。
    * 而且Lean的类型推导能力可能也会超出其他语言使用者的想象，您可以在后续实践中用身体体会。
    * 隐参数 也是基于类型推导来完成的，它和C++中模板函数的类型推导类似，但更为泛用。
        * 注意区分 _ 自动推导和隐参数自动推导，前者对应一个用圆括号定义的参数，而隐参数用花括号定义，
* Lean中的很多计算不需要依靠执行来完成，`#check`和`#eval`提供了一种交互式输出（而非命令行输出）的方式。
    * 事实上使用Lean的大部分时候都依靠交互式而非命令行来工作，尤其是在证明或类型推导的时候。

> 类型宇宙的表格有点难理解，里面的type和term只是一些例子，并不代表这个宇宙所有的类型。
>
> 比如Nat也属于 Type 0(Sort 1)， `a: Nat`，a是一个变量，也属于 Sort 0
> 
> 核心是理解：
> * 所有东西的类型都在下一个宇宙。
> * 一个函数所在的宇宙取决于它所有的参数和返回值中最高的那一个，函数和它在同一个宇宙。
> * 补充：针对宇宙多态的函数没有确定的所属宇宙。
> 
> 这意味着任何东西都有类型，而且任何东西的类型都不可能是它自己

> 事实上隐参数还可以用语法`(参数名:=类型)`来显式提供提供：
> ```
> def a{α: Type} (x: α) : α := 
>  x
> #check a (α:=Int) 1
> ```

### 补充习题

* `def f(a: Type 2): Nat := 0` 问，f属于哪个宇宙？f的类型属于哪个宇宙？怎么使用交互式输出证明你的结论？
* 猜猜下面每个 `#check` 都得到什么类型或出错？然后在交互式输出中验证一下你的猜测。

```
variable {α β γ : Type}
def doTwice (h : α → α) (x : α) : α :=
  h (h x)

#check doTwice
#check doTwice (fun (x: Nat) => x+1)
#check doTwice _ 10
```
* `def Test{a: Type u}(x: a) :=x`属于哪个宇宙？在交互式输出中验证一下你的猜测。

## 第三章：命题与证明

### 导读

本章开始接触命题和证明，并以类型&函数的方式初步的完成证明。

本章第一次开始提供了大量可以实践的习题，终于可以开始自己动手体会Lean的魅力了！

> 注意本章最开头的 Proof 是一个假想的类型，不是真正Lean中的类型。从第二节开始才是真正可以测试的Lean代码。

### 补充阅读

`Prop` 和 `Bool` 很容易被误解成相同的东西，其实它们本质不同

* Prop是所有命题的类型
    * 在类型推导期，Prop可以看做“命题成立的假设”
    * 如果一个命题被实例化，就意味着“命题为真”
    * 如果一个命题作为一个参数，意味着“如果命题为真，则可以blahblah”
    * True是一个Prop，它只有一个取值（代表着它成立），可以被实例化。
    * False是一个Prop，它没有任何取值，所以也不能被实例化（它可以作为参数，但它作为参数的时候也无法调用，除非当前系统已经出现了矛盾）
    * 在运行期，所有的命题只占用0bit，也就是说它们在运行期不存在
    * 合取 `∧` 和析取 `∨` 是关于Prop的函数（在Lean中，运算符实际上都是函数的语法糖）
    * 用单等号比较会得到一个Prop，比如 `a=1` 是一个Prop
* Bool是一个有两个可选值的类型，分别是true和false
    * 使用Monad等技术，可以在函数式语言中弄出一个在编译期不确定的值，此时有必要使用Bool
    * Bool的true和false 都不是类型，它们是Bool的两个具体取值。
    * 运行期Bool占用1bit（不考虑内存对齐等因素的话）。
    * 一个带有Bool参数的函数意味着对应的条件成立或者不成立你都可以调用它（参数分别是true或false）。
    * 用双等号比较会得到一个Bool，比如　`a==1` 是一个Bool
    * 且 `&&` 和或 `||` 是关于Bool的函数
    * 实际上一个确定的Prop可以通过 `Decidable.decide` 转成一个Bool（当然它的值此时也是确定的）。

在证明过程中我们通常使用 `Prop` 。如果你不小心得到了一个非预期的 `Bool` ，你有可能要检查下你弄错了哪里（比如单等号写作双等号）。

Prop的性质决定了我们可以把函数作为证明：

* 我们要证明的目标可能是 “如果A，那么B”
    * 我们可以书写一个函数，它的参数是 ha:A，返回 B
    * 那么任何情况如果我们知道A成立，我们就可以调用这个函数，得到B成立的确切结论。
* 我们要证明的目标可能是 “对于任意的x:α，都有B命题成立”
    * 那么我们可以书写一个函数，它的参数是x:α，返回 B
    * 那么对于任何的x，我们都可以调用这个函数，得到B成立的确切结论。
* 但事实上，只需要证明存在，我们不需要真正的执行它或展开它，就可以把它当做一个结论来使用。
    * 并且证明都是不可执行的，它只在编译期存在。

而公理 `axiom` 就是对我们已知的命题直接提供一个结论，而无需提供证明过程。（所以错误的公理会导致矛盾）

### 补充练习

* 对比 `#check 1=2` 和 `#check 1==2` ，并试一下把 `#check` 改成 `#eval`
* 试着在`Bool`的运算中使用`Prop`，比如 `#check (1=2) || (3=4)` 看看它变成了啥类型。
* 想一下，如果要证明一个命题独立，该怎么定义？（命题独立 也应该是一个命题）
    * 具体的，怎么定义整数a和b的两个命题 `a>0` 和 `b>0` 独立？（只需要给出定义，无需给出证明）
        * 注意整数是`Int`类型而不是`Nat`
        * 可以用 := sorry 来跳过证明并获得一个警告
    * 看看你的定义的定理，用“对于”、“如果”的表述翻译一遍，看看是否正确？
