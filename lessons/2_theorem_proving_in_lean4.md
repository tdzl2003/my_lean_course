# Theorem Proving in Lean 导读

[英文原版](https://lean-lang.org/theorem_proving_in_lean4/)

[中文版](https://www.leanprover.cn/tp-lean-zh/)

## 第一章：简介

### 导读

这一章是介绍一些基础的概念，介绍了计算机和定理证明的历史和Lean的诞生。

如果在这一章中遇到了你理解不了的名词，你可以放心的先跳过，在后面的学习中用身体去感受。

### 补充阅读

有一个概念需要单独提出作为补充： 什么是 [**公理系统**](https://zh.wikipedia.org/wiki/%E5%85%AC%E7%90%86%E7%B3%BB%E7%BB%9F)

事实上，*Lean并不会保证你证明的结论是一定正确的*。Lean只能保证，**在你给定的公理系统下，你证明的某个定理是成立的**。

比如，“一个命题要么是真，要么是假” 这个听起来有道理的论断（被叫做[排中律](https://zh.wikipedia.org/wiki/%E6%8E%92%E4%B8%AD%E5%BE%8B)），本身无法被直接证明，所以我们把它当做 “经典逻辑系统” 的一部分。

然而，你也可以不承认排中律，构建其他的公理系统（比如直觉逻辑系统），你也可以得到一部分有趣的结论，并非所有的定理都依赖排中律。

另外，你也可以引入一些并不符合常识的公理，比如 $1>2$ 。引入这种公理可能会和现有的其他公理产生矛盾。后面我们会看到，如果发生了这种事，你可能可以证明出“False”为真，然后随之可以证明出所有的命题都为真。这时候我们叫做这个系统“不自洽”。“不自洽”的系统通常没有太大研究的价值（因为所有命题都可以被证明为真），所以我们通常所研究的公理系统应当是自洽的。

Lean的另一个作用就是，**在你完成一个证明后，Lean可以自动帮你推导出你的证明实际依赖了哪些公理**。在数学研究中，有时候需要研究一个公理的独立性。

* 如果你从一些基础公理能够证明出一个新的命题，那么这个新命题不是独立的。
* 如果你能够证明 不能从基础公理证明出一个新的命题，那这个命题是独立的。
    * 注意“不能证明”本身也是需要证明的，只是“没有做到”并非严格的独立性证明。
    * 证明独立性的一种方法，是 如果存在一个基础命题推导出该新命题的证明，则可以推出一个矛盾，那么就可以证明不存在这样的证明了。

### 补充习题

* 回忆一下你在数学中学习过的证明，或者上网搜索一个关于任意数学命题的证明，想一想，他依赖了哪些公理？
    * 未来在你学习完Lean的形式化证明之后，试着形式化一下这个命题，看看它到底依赖了哪些公理，和你最初的想象一样吗？

## 第二章：依值类型论

### 导读

这一章主要是讲解了Lean 4中的类型系统和相关的语法及概念。

对于计算机出身的，或者至少学习过一门以上静态类型语言（比如C++或Java）的同学来说 这一章的大部分内容应该比较轻松。你可以先阅读，然后再来阅读接下来的补充材料。

### 补充阅读

相信这一章的大部分内容阅读起来不算困难，有几个重要的点（也是和C++或Java等语言的不同之处）需要注意：

* 函数是一等公民
    * 就像JavaScript、Python等语言一样
    * 函数可以作为参数传递，也可以返回，支持高阶函数等等
* 类型也是一等公民
    * 这是极少语言具备的特性，只有C++模板元编程 有类似的特性。
        * 但C++的模板元编程和普通代码语法截然不同
        * 而Lean中处理类型的函数和普通函数语法上是一致的。虽然这种函数（依值类型函数）只能在编译期使用，不会生成任何的可执行代码。
    * 这意味着“模板类型”、“模板函数”、“普通函数”这在C++里截然不同的三个东西，在Lean中其实是一样的表达。
    * 这意味着类型本身也有类型，这就是类型宇宙的概念。
        * 大部分时候并不需要具体的关心类型属于哪个宇宙，可以使用多态来处理不同的类型宇宙
* 有很多类型的推导可以自动完成
    * 实际上这是比想象的重要的多的特性，很多证明过程、对命题的模式匹配等都广泛依赖这个特性。
    * 而且Lean的类型推导能力可能也会超出其他语言使用者的想象，您可以在后续实践中用身体体会。
    * 隐参数 也是基于类型推导来完成的，它和C++中模板函数的类型推导类似，但更为泛用。
        * 注意区分 _ 自动推导和隐参数自动推导，前者对应一个用圆括号定义的参数，而隐参数用花括号定义，
* Lean中的很多计算不需要依靠执行来完成，`#check`和`#eval`提供了一种交互式输出（而非命令行输出）的方式。
    * 事实上使用Lean的大部分时候都依靠交互式而非命令行来工作，尤其是在证明或类型推导的时候。

> 依值类型函数 很像C++中的`模板元函数`，它返回一个类型，所以总是在编译期而非运行期执行。下面是一个C++中模板元函数的例子
> ```
> template <typename arg1, typename arg2>
> struct fun{
>   typedef map<arg1, arg2> type;
> };
> ```
> 它的调用方式是 `func<int, bool>::type` 而这个调用返回的是 `map<int,bool>` 这个类型。
> 
> 在Lean中，类似“模板类”的功能也被“依值类型函数”完成，例如 `Prod` 很像C++中的 `pair` 。

> 类型宇宙的表格有点难理解，里面的type和term只是一些例子，并不代表这个宇宙所有的类型。
>
> 比如Nat也属于 Type 0(Sort 1)， `a: Nat`，a是一个变量，也属于 Sort 0
> 
> 核心是理解：
> * 所有东西的类型都在下一个宇宙。
> * 一个函数所在的宇宙取决于它所有的参数和返回值中最高的那一个，函数和它在同一个宇宙。
> * 补充：针对宇宙多态的函数没有确定的所属宇宙。
> 
> 这意味着任何东西都有类型，而且任何东西的类型都不可能是它自己

> 事实上隐参数还可以用语法`(参数名:=类型)`来显式提供提供：
> ```
> def a{α: Type} (x: α) : α := 
>  x
> #check a (α:=Int) 1
> ```


### 补充习题

1. `def f(a: Type 2): Nat := 0` 问，f属于哪个宇宙？f的类型属于哪个宇宙？怎么使用交互式输出证明你的结论？
2. 猜猜下面每个 `#check` 都得到什么类型或出错？然后在交互式输出中验证一下你的猜测。

```
variable {α β γ : Type}
def doTwice (h : α → α) (x : α) : α :=
  h (h x)

#check doTwice
#check doTwice (fun (x: Nat) => x+1)
#check doTwice _ 10
```
* `def Test{a: Type u}(x: a) :=x`属于哪个宇宙？在交互式输出中验证一下你的猜测。

## 第三章：命题与证明

### 导读

本章开始接触命题和证明，并以类型&函数的方式初步的完成证明。

本章第一次开始提供了大量可以实践的习题，终于可以开始自己动手体会Lean的魅力了！

> 注意本章最开头的 Proof 是一个假想的类型，不是真正Lean中的类型。从第二节开始才是真正可以测试的Lean代码。

### 补充阅读

`Prop` 和 `Bool` 很容易被误解成相同的东西，其实它们本质不同

* Prop是所有命题的类型
    * 在类型推导期，Prop的实例可以看做“命题成立的假设”，如果一个命题存在实例，就意味着“命题为真”
    * 如果一个命题P作为另一个函数的一个参数，意味着“如果命题为真，则可以blahblah”
        * 如果另一个函数返回值是一个Prop，那么那个函数是一个“蕴含”命题的证明，P是蕴含中的前提
        * 如果另一个函数返回值是一个普通数据类型，那么函数是一个普通函数，而P是调用该函数需要证明的前提。
    * True是一个Prop，它只有一个取值，代表它可以被实例化。所以True命题是成立的。
    * False是一个Prop，它没有任何取值，所以也不能被实例化（它可以作为参数，但它作为参数的时候也无法调用，除非当前公理系统已经出现了矛盾）所以False命题是假的。
    * 在运行期，所有的命题只占用0bit，也就是说它们在运行期不存在
    * 合取 `∧` 和析取 `∨` 是关于Prop的函数（在Lean中，运算符实际上都是函数的语法糖）
    * 用单等号比较会得到一个Prop，比如 `a=1` 是一个Prop
* Bool是一个有两个可选值的类型，分别是true和false
    * 使用Monad等技术，可以在函数式语言中弄出一个在编译期不确定的值，此时有必要使用Bool
    * Bool的true和false 都不是类型，它们是Bool的两个具体取值。
    * 运行期Bool占用1bit（不考虑内存对齐等因素的话）。
    * 一个带有Bool参数的函数意味着对应的条件成立或者不成立你都可以调用它（参数分别是true或false）。
    * 用双等号比较会得到一个Bool，比如　`a==1` 是一个Bool
    * 且 `&&` 和或 `||` 是关于Bool的函数
    * 实际上一个确定的Prop可以通过 `Decidable.decide` 转成一个Bool（当然它的值此时也是确定的）。

在证明过程中我们通常使用 `Prop` 。如果你不小心得到了一个非预期的 `Bool` ，你有可能要检查下你弄错了哪里（比如单等号写作双等号）。

Prop的性质决定了返回Prop的函数的类型也是Prop，而这个函数的实现就作为相应的证明：

* 我们要证明的目标可能是 “如果A，那么B”
    * 我们可以书写一个函数，它的参数是 ha:A，返回 B
    * 那么任何情况如果我们知道A成立，我们就可以调用这个函数，得到B成立的确切结论。
* 我们要证明的目标可能是 “对于任意的x:α，都有B命题成立”
    * 那么我们可以书写一个函数，它的参数是x:α，返回 B
    * 那么对于任何的x，我们都可以调用这个函数，得到B成立的确切结论。
* 我们要证明的目标可能是“X不成立”
    * 那么我们可以证明如果X成立，我们一定可以推出矛盾(False)
    * 所以否定 `¬X` 等价于 `X→False`
* 但事实上，只需要证明存在，我们不需要真正的执行它或展开它，就可以把它当做一个结论来使用。
    * 并且证明都是不可执行的，它只在编译期存在。

公理 `axiom` 就是对我们已知的命题直接提供一个结论，而无需提供证明过程。（所以错误的公理会导致矛盾）
而定理 `theorem` 则是使用已有的公理得到当前命题的一个定义（即实例化这个函数/命题），如果 `theorem` 编写成功，则意味着对应的命题在相应公理体系下是正确的。

关于合取和析取还有两点事实需要理解：

* 合取同时是一个结构体，两个成员分别表示两个子命题成立的证明或假设
    * 如果你拿到了合取成立的证明或假设，就可以得到两个子命题各自成立的证明或假设
    * 如果你想要得到一个合取成立的证明，就需要分别提供两个子命题成立的证明或假设
* 析取同时是一个枚举类型，两种枚举情况分别表示两个子命题成立的证明或假设。
    * 如果你拿到了析取成立的证明或假设，你可以分别讨论两个子命题各自成立的情况，在两种情况均给出你的证明目标，就可以证明你的目标结论。
    * 如果你想要得到一个析取成立的证明，你只需要提供它任意一个自命题成立的证明或假设。

### 补充练习

1. 对比 `#check 1=2` 和 `#check 1==2` ，并试一下把 `#check` 改成 `#eval`
2. 试着在`Bool`的运算中使用`Prop`，比如 `#check (1=2) || (3=4)` 看看它变成了啥类型。
3. 想一下，如果要证明一个命题对另一个命题独立，该怎么定义？（命题独立 也应该是一个命题）
    * 具体的，怎么定义整数a和b的两个命题  `b>0` 对 `a>0` 独立？（只需要给出定义，无需给出证明）
        * 注意整数是`Int`类型而不是`Nat`
        * 可以用 := sorry 来跳过证明并获得一个警告
    * 看看你的定义的定理，用“对于”、“如果”的表述翻译一遍，看看是否正确？
4. 对比 `#check (a: Nat)→Prop` 和 `#check (a: Nat)→Nat` 看看Message中有哪些区别？为什么会这样？猜一猜，`#check (a: Nat)→a=1` 是一个 `Prop` 还是一个 `Type` ？

## 第四章：量词与等价

### 导读

量词 和 等价关系 都是数学中的重要概念，这一章我们依次学习这两个概念，并学习几个相关的新语法。

读之前，看看如下数学概念是否有了解，没有的话，先从维基百科开始简单了解一下：

* [全称量词](https://zh.wikipedia.org/zh-cn/%E5%85%A8%E7%A7%B0%E9%87%8F%E5%8C%96)
* [存在量词](https://zh.wikipedia.org/zh-cn/%E5%AD%98%E5%9C%A8%E9%87%8F%E5%8C%96)
* [相等](https://zh.wikipedia.org/wiki/%E7%9B%B8%E7%AD%89)
    * 注意在中文版中的“等价” 指的是“相等”，它和“[等价关系](https://zh.wikipedia.org/zh-cn/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB)”不是同一个意思
    * `a=b` 意味着在任何地方都可以用 `a` 去替换 `b` ，它是一个等价关系，但并非所有等价关系都是相等。

### 补充阅读

* 全称量词 `∀ a:α, p` 等价于 `(a:α) → p` ，所以它本质上是一个函数。
    * 全称量词的“消去”可以看做调用了这个函数。虽然因为它们都是命题，这个调用不会有代码真正的被“执行”
    * 注意这一章没有提到另一种语法 `∀ a ∈ S, p`，其实它是 `∀ a, a ∈ S → p` 的语法糖。 想想，为什么？
* 存在量词 `∃ a:α, p` 是一个结构体
    * 它包含 `choose` 和 `choosespec` 两个成员，分别是一个使p成立的实例 和 它使p成立的证明。
    * `∃ a ∈ S, p` 是 `∃ a, a ∈ s ∧ p` 的语法糖。注意这和全称量词的区别。想想，为什么？
* 逻辑相等
    * `a ↔ b` 表示命题 `a` 和 `b` 在逻辑上是等效的，所以事实上 `a` 和 `b` 也相等。
        * 在Lean里，这是一个公理，叫做 `propext`。 `axiom propext {a b : Prop} : (a ↔ b) → a = b`
    * 相反，如果命题 `a` 和 `b` 相等，它们显然也可以互相推出。这个定理是 `theorem Iff.of_eq (h : a = b) : a ↔ b := h`
    * 这两个命题整合在一起，可以得到 `theorem iff_iff_eq : (a ↔ b) ↔ a = b`
    * 事实上这可以得到 `(a ↔ b) = (a = b)` 所以在后续证明中需要替换命题的时候，`↔` 和 `=` 均可以用于替换。
* calc在计算类问题中广泛使用
    * 事实上，逻辑相等也可以使用calc（运算符使用↔）
* Classical 命名空间代表了“[经典逻辑系统](https://zh.wikipedia.org/zh-cn/%E9%80%BB%E8%BE%91#%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91)”
    * 排中律作为公理在该命名空间中定义，缺少该公理会有很多定理无法证明。

### 补充练习

1. 想一想，`∃ a:α, False` 表示了什么？ `∀ a:α, False` 呢？它们有什么区别？
2. 尝试用 `calc` 化简计算并证明：`example : 5 * x - 3 * x = 2 * x`
3. `calc` 也可以用于逻辑等价，尝试用 `calc` 变形并求解方程 `example : ∀ x:ℝ, x+3=5 ↔ x=2`
    * 提示：中间过程可以使用定理 `sub_eq_iff_eq_add`

