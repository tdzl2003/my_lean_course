# Theorem Proving in Lean 导读

[英文原版](https://lean-lang.org/theorem_proving_in_lean4/)

[中文版](https://www.leanprover.cn/tp-lean-zh/)

## 第一章：简介

### 导读

这一章是介绍一些基础的概念，介绍了计算机和定理证明的历史和Lean的诞生。

如果在这一章中遇到了你理解不了的名词，你可以放心的先跳过，在后面的学习中用身体去感受。

### 补充阅读

有一个概念需要单独提出作为补充： 什么是 [**公理系统**](https://zh.wikipedia.org/wiki/%E5%85%AC%E7%90%86%E7%B3%BB%E7%BB%9F)

事实上，*Lean并不会保证你证明的结论是一定正确的*。Lean只能保证，**在你给定的公理系统下，你证明的某个定理是成立的**。

比如，“一个命题要么是真，要么是假” 这个听起来有道理的论断（被叫做[排中律](https://zh.wikipedia.org/wiki/%E6%8E%92%E4%B8%AD%E5%BE%8B)），本身无法被直接证明，所以我们把它当做 “经典逻辑系统” 的一部分。

然而，你也可以不承认排中律，构建其他的公理系统（比如直觉逻辑系统），你也可以得到一部分有趣的结论，并非所有的定理都依赖排中律。

另外，你也可以引入一些并不符合常识的公理，比如 $1>2$ 。引入这种公理可能会和现有的其他公理产生矛盾。后面我们会看到，如果发生了这种事，你可能可以证明出“False”为真，然后随之可以证明出所有的命题都为真。这时候我们叫做这个系统“不自洽”。“不自洽”的系统通常没有太大研究的价值（因为所有命题都可以被证明为真），所以我们通常所研究的公理系统应当是自洽的。

Lean的另一个作用就是，**在你完成一个证明后，Lean可以自动帮你推导出你的证明实际依赖了哪些公理**。在数学研究中，有时候需要研究一个公理的独立性。

* 如果你从一些基础公理能够证明出一个新的命题，那么这个新命题不是独立的。
* 如果你能够证明 不能从基础公理证明出一个新的命题，那这个命题是独立的。
    * 注意“不能证明”本身也是需要证明的，只是“没有做到”并非严格的独立性证明。
    * 证明独立性的一种方法，是 如果存在一个基础命题推导出该新命题的证明，则可以推出一个矛盾，那么就可以证明不存在这样的证明了。

### 补充习题

* 回忆一下你在数学中学习过的证明，或者上网搜索一个关于任意数学命题的证明，想一想，他依赖了哪些公理？
    * 未来在你学习完Lean的形式化证明之后，试着形式化一下这个命题，看看它到底依赖了哪些公理，和你最初的想象一样吗？

## 第二章：依值类型论

### 导读

这一章主要是讲解了Lean 4中的类型系统和相关的语法及概念。

对于计算机出身的，或者至少学习过一门以上静态类型语言（比如C++或Java）的同学来说 这一章的大部分内容应该比较轻松。你可以先阅读，然后再来阅读接下来的补充材料。

### 补充阅读

相信这一章的大部分内容阅读起来不算困难，有几个重要的点（也是和C++或Java等语言的不同之处）需要注意：

* 函数是一等公民
    * 就像JavaScript、Python等语言一样
    * 函数可以作为参数传递，也可以返回，支持高阶函数等等
* 类型也是一等公民
    * 这是极少语言具备的特性，只有C++模板元编程 有类似的特性。
        * 但C++的模板元编程和普通代码语法截然不同
        * 而Lean中处理类型的函数和普通函数语法上是一致的。虽然这种函数（依值类型函数）只能在编译期使用，不会生成任何的可执行代码。
    * 这意味着“模板类型”、“模板函数”、“普通函数”这在C++里截然不同的三个东西，在Lean中其实是一样的表达。
    * 这意味着类型本身也有类型，这就是类型宇宙的概念。
        * 大部分时候并不需要具体的关心类型属于哪个宇宙，可以使用多态来处理不同的类型宇宙
* 有很多类型的推导可以自动完成
    * 实际上这是比想象的重要的多的特性，很多证明过程、对命题的模式匹配等都广泛依赖这个特性。
    * 而且Lean的类型推导能力可能也会超出其他语言使用者的想象，您可以在后续实践中用身体体会。
    * 隐参数 也是基于类型推导来完成的，它和C++中模板函数的类型推导类似，但更为泛用。
        * 注意区分 _ 自动推导和隐参数自动推导，前者对应一个用圆括号定义的参数，而隐参数用花括号定义，
* Lean中的很多计算不需要依靠执行来完成，`#check`和`#eval`提供了一种交互式输出（而非命令行输出）的方式。
    * 事实上使用Lean的大部分时候都依靠交互式而非命令行来工作，尤其是在证明或类型推导的时候。

> 类型宇宙的表格有点难理解，里面的type和term只是一些例子，并不代表这个宇宙所有的类型。
>
> 比如Nat也属于 Type 0(Sort 1)， `a: Nat`，a是一个变量，也属于 Sort 0
> 
> 核心是理解：每个类型，它的类型都属于它下一级的宇宙。Sort 0包含了所有的运行期值，Type 0(Sort 1)包含了所有Sort 0中元素的类型 和 使用或返回这些元素的函数；Type 1(Sort 2)包含了Type 0(Sort 1)中的所有类型 和 使用或返回这些类型的依值类型函数，等等。
>
> * 所有东西的类型都在下一个宇宙。
> * 一个依值类型所在的宇宙取决于它所有的参数中最高的那一个，依值类型和它在同一个宇宙。
> * 一个函数所在的宇宙取决于它所有的参数和返回值中最高的那一个，函数和它在同一个宇宙。
> 
> 这意味着任何东西都有类型，而且任何东西的类型都不可能是它自己

> 事实上隐参数还可以用语法`(参数名:=类型)`来显式提供提供：
> ```
> def a{α: Type} (x: α) : α := 
>  x
> #check a (α:=Int) 1
> ```

### 补充习题

* `def f(a: Type 2): Nat := 0` 问，f在哪个宇宙？f的类型在哪个宇宙？怎么使用交互式输出证明你的结论？
* 猜猜下下面每个 `#check` 都得到什么类型或出错？然后在交互式输出中验证一下你的猜测。

```
variable {α β γ : Type}
def doTwice (h : α → α) (x : α) : α :=
  h (h x)

#check doTwice
#check doTwice (fun (x: Nat) => x+1)
#check doTwice _ 10
```
